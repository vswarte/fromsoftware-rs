//! Serializes struct definitions to Rust.

use std::collections::HashMap;

use crate::{FieldType, LayoutUnit, StructDef};

pub fn generate_rust(definitions: Vec<StructDef>) -> String {
    let mut output = String::new();

    output.push_str("//! Param bindings generated from paramdef XMLs.\n\n");

    output.push_str("// DO NOT EDIT THIS FILE DIRECTLY.\n\n");

    output.push_str("/// Trait to perform safe param lookups.\n");
    output.push_str("pub trait ParamDef {\n");
    output.push_str("    /// The all-caps, snake-case name of the parameter definition.\n");
    output.push_str("    const NAME: &str;\n");

    if definitions[0].index.is_some() {
        output.push('\n');
        output.push_str("    /// The index in the global parameter repository of the *first*\n");
        output.push_str("    /// parameter with this definition. Some definitions are re-used\n");
        output.push_str("    /// across multiple parameters, which are usually contiguous in\n");
        output.push_str("    /// the repository.\n");
        output.push_str("    const INDEX: usize;\n");
    }

    output.push_str("}\n\n");

    for definition in &definitions {
        output.push_str(&generate_struct(definition));
    }

    output
}

fn generate_struct(def: &StructDef) -> String {
    let mut code = String::new();

    // Group the bitfields
    let mut bitfield_groups: HashMap<usize, Vec<(&LayoutUnit, u8)>> = HashMap::new();
    for unit in def.layout.iter() {
        if let FieldType::Bitfield(_) = unit.field_type {
            bitfield_groups
                .entry(unit.offset)
                .or_default()
                .push((unit, unit.size as u8));
        }
    }
    let mut grouped_names = HashMap::new();

    code.push_str("#[derive(Debug, Clone)]\n");
    code.push_str("#[allow(non_camel_case_types)]\n");
    code.push_str("#[repr(C)]\n");

    code.push_str(&format!("pub struct {} {{\n", def.name));
    for unit in def.layout.iter() {
        match &unit.field_type {
            FieldType::Bitfield(_) => {
                if grouped_names.contains_key(&unit.offset) {
                    continue;
                }

                let group_name = format!("bits_{:x}", &unit.offset);

                code.push_str(&format!("    {}: u8,\n", &group_name));

                grouped_names.insert(unit.offset, group_name);
            }
            FieldType::Standard(_) => {
                code.push_str(&format!(
                    "    {}: {},\n",
                    normalize_name(&unit.name),
                    unit.field_type.native_type()
                ));
            }
            FieldType::Array(inner_type, count) => {
                code.push_str(&format!(
                    "    {}: [{}; {}],\n",
                    normalize_name(&unit.name),
                    inner_type.native_type(),
                    count,
                ));
            }
        }
    }
    code.push_str("}\n\n");

    code.push_str(&format!("impl ParamDef for {} {{\n", def.name));
    code.push_str(&format!("    const NAME: &str = \"{}\";\n", def.name));

    if let Some(index) = def.index {
        code.push_str(&format!("    const INDEX: usize = {};\n", index));
    }
    code.push_str("}\n\n");

    code.push_str(&format!("impl {} {{\n", def.name));
    for unit in def.layout.iter() {
        if unit.hidden() {
            continue;
        }

        let normalized_name = normalize_name(&unit.name);
        match &unit.field_type {
            FieldType::Bitfield(bits) => {
                let group_name = &grouped_names[&unit.offset];
                let used_bits: u8 = bitfield_groups[&unit.offset]
                    .iter()
                    .take_while(|(u, _)| u.name != unit.name)
                    .map(|(_, b)| *b)
                    .sum();

                let mask = (1 << bits) - 1;

                code.push_str("    #[allow(clippy::identity_op)]\n");
                code.push_str(&format!(
                    "    pub fn {normalized_name}(&self) -> u8 {{\n        (self.{group_name} >> {used_bits}) & 0b{mask:08b}\n    }}\n\n"
                ));

                code.push_str("    #[allow(clippy::identity_op)]\n");
                code.push_str(&format!(
                    "    pub fn set_{normalized_name}(&mut self, value: u8) {{\n        self.{group_name} = (self.{group_name} & !(0b{mask:08b} << {used_bits})) | ((value & 0b{mask:08b}) << {used_bits});\n    }}\n\n"
                ));
            }
            FieldType::Standard(arg) if arg == "b32" => {
                code.push_str(&format!(
                    "    pub fn {}(&self) -> bool {{\n        self.{} != 0\n    }}\n\n",
                    normalized_name, normalized_name
                ));
                code.push_str(&format!(
                    "    pub fn set_{}(&mut self, value: bool) {{\n        self.{} = value as {};\n    }}\n\n",
                    normalized_name, normalized_name, unit.field_type.native_type()
                ));
            }
            FieldType::Standard(_) => {
                code.push_str(&format!(
                    "    pub fn {}(&self) -> {} {{\n        self.{}\n    }}\n\n",
                    normalized_name,
                    unit.field_type.native_type(),
                    normalized_name
                ));
                code.push_str(&format!(
                    "    pub fn set_{}(&mut self, value: {}) {{\n        self.{} = value;\n    }}\n\n",
                    normalized_name, unit.field_type.native_type(), normalized_name
                ));
            }
            FieldType::Array(inner, count) => {
                code.push_str(&format!(
                    "    pub fn {}(&self) -> &[{}; {}] {{\n        &self.{}\n    }}\n\n",
                    normalized_name,
                    inner.native_type(),
                    count,
                    normalized_name
                ));
                code.push_str(&format!(
                    "    pub fn set_{}(&mut self, value: [{}; {}]) {{\n        self.{} = value;\n    }}\n\n",
                    normalized_name, inner.native_type(), count, normalized_name
                ));
            }
        }
    }
    code.push_str("}\n\n");

    code
}

fn normalize_name(mut name: &str) -> String {
    // type is a reserved keyword, so we cannot name properties that.
    if name == "type" {
        name = "typ";
    }

    let mut result = String::with_capacity(name.len());
    let mut prev_char: Option<char> = None;

    for (i, ch) in name.chars().enumerate() {
        if ch.is_ascii_alphanumeric() {
            if ch.is_uppercase() {
                if let Some(prev) = prev_char {
                    if prev.is_lowercase() || (prev.is_numeric() && i > 0) {
                        result.push('_');
                    } else if prev.is_uppercase() {
                        // Look ahead to avoid splitting acronyms prematurely
                        if let Some(next) = name.chars().nth(i + 1)
                            && next.is_lowercase()
                        {
                            result.push('_');
                        }
                    }
                }
                result.push(ch.to_ascii_lowercase());
            } else {
                result.push(ch);
            }
        } else {
            // Replace symbols (non-alphanumerics) with a single underscore
            if !result.ends_with('_') {
                result.push('_');
            }
        }
        prev_char = Some(ch);
    }

    // Remove leading/trailing/multiple underscores
    result
        .split('_')
        .filter(|s| !s.is_empty())
        .collect::<Vec<_>>()
        .join("_")
}
