//! Serializes struct definitions to Rust.

use std::collections::HashMap;

use crate::{FieldType, LayoutUnit, StructDef};

pub fn generate_c(definitions: Vec<StructDef>) -> String {
    let mut output = String::new();

    output.push_str("//! C headers generated from paramdef XMLs.\n\n");

    output.push_str("// DO NOT EDIT THIS FILE DIRECTLY.\n\n");

    for definition in &definitions {
        output.push_str(&generate_struct(definition));
    }

    output
}

fn generate_struct(def: &StructDef) -> String {
    let mut code = String::new();

    // Group the bitfields
    let mut bitfield_groups: HashMap<usize, Vec<(&LayoutUnit, u8)>> = HashMap::new();
    for unit in def.layout.iter() {
        if let FieldType::Bitfield(_) = unit.field_type {
            bitfield_groups
                .entry(unit.offset)
                .or_default()
                .push((unit, unit.size as u8));
        }
    }
    let mut grouped_names = HashMap::new();

    code.push_str(&format!("struct {} {{\n", def.name));
    for unit in def.layout.iter() {
        match &unit.field_type {
            FieldType::Bitfield(_) => {
                if grouped_names.contains_key(&unit.offset) {
                    continue;
                }

                let group_name = format!("bits_{:x}", &unit.offset);

                code.push_str(&format!("    uint8_t {};\n", &group_name));

                grouped_names.insert(unit.offset, group_name);
            }
            FieldType::Standard(_) => {
                code.push_str(&format!(
                    "    {} {};\n",
                    unit.field_type.c_type(),
                    &unit.name,
                ));
            }
            FieldType::Array(inner_type, count) => {
                code.push_str(&format!(
                    "    {} {}[{}];\n",
                    inner_type.c_type(),
                    &unit.name,
                    count,
                ));
            }
        }
    }
    code.push_str(&format!("}} {};\n\n", &def.name));

    code
}
